# 自增列可用性检查

## 应用场景

该巡检项检查已有的全局自增列是否够用

## 前置条件

无

## 技术原理

OceanBase作为分布式数据库，表通常分布在多台不同的机器，在尽可能和MySQL兼容的同时需要保证分布式多机的自增列生成性能，从而出现了自增值生成过程中的跳变。
在OceanBase的4.x版本，存在两种自增模式（`AUTO_INCREMENT_MODE`)的自增列表，分别是`ORDER`和`NOORDER`模式，默认是`ORDER`,使用show create table可以查看包含自增列表的自增模式:

```sql
CREATE TABLE `T1` (
  `c1` int(11) NOT NULL AUTO_INCREMENT,
  `c2` smallint(6) DEFAULT NULL,
  PRIMARY KEY (`c1`)
) AUTO_INCREMENT = 1 AUTO_INCREMENT_MODE = 'ORDER'
```

在OceanBase 4.x指定`AUTO_INCREMENT_MODE = 'NOORDER'`和OceanBase 4.0以下版本创建的包含自增列的表，都是NORDER模式的自增表。OceanBase 4.x新增了ORDER模式的自增列，并且为建表的默认模式，更好地兼容MySQL行为。

## 排查步骤

如果巡检发现自增列异常增长（表现为很快突破阈值），需要针对上述两种自增列模式进行排查：

- NORDER
   - 场景1: 机器重启/宕机

ORDER模式在leader节点维护了内存下的缓存区间，当leader节点发生重启/宕机时，该区间内未使用的自增值不会被继续使用，从而发生跳变。注意，这里跳变的场景仅发生在leader节点，其它follower节点由于不保存缓存，即使宕机也不会影响自增值的生成连续性。

   - 场景2: 切主

当发生切主时，为了避免来回切主从而导致的自增值不递增问题:

      - 比如obs2起始缓存为【1，100】生成1，2；
      - 切主到obs1，obs1得到新的缓存区间【101，200】生成101，102；
      - 再次切回obs2，继续复用上一次的缓存，得到3，4，从101到3发生了不递增的问题；
- ORDER
   - 场景1: 多机多分区生成自增值

假设auto_increment_cache_size为100，举例说明当分区表存在的obs1、obs2、obs3分别均匀接收到`insert into values (null)`请求时，它们的行为:

      - obs1 发现自身没有缓存时，向内部表申请一段自增区间【1, 100】，并且生成一个自增值1；
      - obs2 发现自身没有缓存时，向内部表申请一段自增区间【101, 200】，并且生成一个自增值101；
      - obs3 发现自身没有缓存时，向内部表申请一段自增区间【201, 300】，并且生成一个自增值201；
      - obs1 使用缓存【2，100】生成自增值2；
      - obs2 使用缓存【102，200】生成自增值102；
      - ...

这样表内的插入数据顺序为1，101，201，2，102，... 可以发现自增值总是在发生跳变。

   - 场景2: INSERT插入指定最大值

在MySQL的行为中，如果显式往自增列插入指定值，那么后续生成的自增值都不会小于该值。
在OceanBase的分布式场景下，不光需要obs本身知道当前插入了一个最大值，还需要同步给其它server和内部表，这个同步动作十分耗时，为了避免每次指定最大值时都做同步操作，会在insert一个最大值时放弃掉当前的缓存，这样从当前值开始到下一个缓存值前都不需要进行同步。
当分区表存在的obs1、obs2、obs3分别均匀接收到显式指定递增序列(1, 2, 3, ...) 请求时，并且假设它们原始都存在缓存的行为:

      - obs1 接收到1，放弃掉缓存【1，100】，重新从内部表获取到一段新的缓存区间【301，400】，并且把101作为一个sync值同步到内部表和其它obs；
      - obs2 接收到2，发现比当前的缓存区间小【101，200】，不做操作；
      - obs3 接收到3，发现比当前的缓存区间小【201，300】，不做操作；
      - obs1 接收到4，发现比当前的缓存区间小【301，400】，不做操作；
      - ...

这样如果插入部分值后继续使用自增列生成序列，就会发生跳变，比如obs1第一个区间【1，100】都没有使用而是直接跳到了301，该问题单机场景也会出现:
```sql
obclient> create table t1 (c1 int not null auto_increment);
obclient> insert into t1 values (null);
obclient> insert into t1 values (3);
obclient> insert into t1 values (null);
obclient> select * from t1;
+-----+
| c1  |
+-----+
|   1 |
|   3 |
| 104 | -- 跳变一个cache size大小
+-----+
3 rows in set (0.05 sec)
```

   - 场景3: 机器重启/宕机

自增列缓存是一个内存结构，如果obs发生了重启/宕机，这部分未使用完的区间不会写回内部表，导致这部分区间不会再被使用，比如obs1 初始自增列缓存区间为【1，100】，并且已经生成了1，2，此时发生了宕机，重启后变成了新的区间【101，200】，下一次的自增值为101，序列1，2，101，...发生了跳变。

   - 场景4: 切主

在OceanBase 4.0以下版本中，自增列不保证连续，但是需要保证分区内递增，为了保证这个行为，每次切主时会放弃掉当前的缓存区间，从而出现类似机器重启的自增值跳跃行为，这里不再赘述。
